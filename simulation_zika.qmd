---
title: "Epidemie_Zika"
date: "`r Sys.Date()`"
format:
  html:
    toc: true
    toc-floating: true
    number-sections: true
    code-fold: true
    embed-resources: true
    toc-depth: 4
    theme: cosmo
    highlight-style: pygments
    fig.align: center
---

# Packages

```{r, message = FALSE, warning = FALSE}
library(outbreaks)
library(dplyr)
library(ggplot2)
library(deSolve)
library(abc)
library(ggplot2)
library(data.table)

# install.packages("devtools")
# Installer BRREWABC depuis GitHub
library(devtools)
# install_github("gaelbn/BRREWABC")
library(BRREWABC)
library(GGally)
```

# Data
```{r}
data <- zika_sanandres_2015
```

```{r}
plot(data, pch = 19)
data$cumule <- cumsum(data$cases)
plot(x= data$date, y=data$cumule)

ggplot(data, aes(x = date, y = cases))+
  geom_line() + 
  geom_point(alpha = 0.7) +
  theme_bw()
```

## Rajouter les pas de temps manquants (avec des NA)
Pour avoir la bonne taille de data.frame (par rapport à la simulation)
```{r}
tt_data <- seq(from = min(data$date), to = max(data$date), by = "day")
tt_data <- data.frame(date = tt_data) %>%
  left_join(., data, by = "date")
```

## Données en cumulées par semaine depuis le début de suivi
```{r}
data_sem <- tt_data %>%
  mutate(week = floor(as.numeric(date - min(date))/7)) %>%
  group_by(week) %>%
  summarize(cases = sum(cases, na.rm = TRUE))
```

## Données météo 
```{r}
# plot(as.Date(era5$valid_time), era5$tp)
# plot(as.Date(era5$valid_time), era5$sst)
```

```{r}
# data %>%
#   left_join(., era5, by = c("date" = "valid_time"))
```

# SEIR + SEI discret
```{r}
seirs_ode <- function(t, state, pars) {
  with(as.list(c(state, pars)), {
    
    N_H <- S_H + E_H + I_H + R_H
    N_M <- S_M + E_M + I_M
    
    lambda_H <- a * b_MH * I_M / N_H  # force of infection
    lambda_M <- a * b_HM * I_H / N_H
    
    # Humains 
    dS_H <-  - lambda_H * S_H 
    dE_H <-  lambda_H * S_H - sigma_H * E_H
    dI_H <-  sigma_H * E_H - gamma_H * I_H
    dR_H <-  gamma_H * I_H
    
    # Moustiques
    dS_M <-  mu_M * N_M - lambda_M * S_M - mu_M * S_M
    dE_M <-  lambda_M * S_M - sigma_M * E_M - mu_M * E_M
    dI_M <-  sigma_M * E_M - mu_M * I_M

    list(c(dS_H, dE_H, dI_H, dR_H,
      dS_M, dE_M, dI_M))
  })
}
```

Paramètres : 
```{r}
parameters <- c(

  # Populations
  N_H = 55000,
  N_M = 30000, # ?

  # Transmission
  a     = 0.5,      # piqûres / moustique / jour
  b_MH  = 0.3,      # moustique -> humain
  b_HM  = 0.3,      # humain -> moustique

  # Humains
  sigma_H = 1/5,    # durée incubation humaine : 5j
  gamma_H = 1/5,    # durée infection : 4.7j

  # Moustiques
  sigma_M = 1/10,   # durée incubation : 10j ?
  mu_M    = 1/15    # durée vie : 10j ?
)
```

Insecticide dans les avions : transmission du zika à San Andrès vient de H
```{r}
init <- c(
  S_H = as.numeric(parameters["N_H"] - 1),
  E_H = 0,
  I_H = 1,
  R_H = 0,

  S_M = as.numeric(parameters["N_M"]),
  E_M = 0,
  I_M = 0
)

times <- seq(0, 146, by = 1) # mettre + long 

out <- ode(
  y = init,
  times = times,
  func = seirs_ode,
  parms = parameters,
  method = "rk4"
)

out <- as.data.frame(out)
```

Incidence : nombre de nouvelles infectionns par jour 
```{r}
out$incidence <- parameters["sigma_H"] * out$E_H

plot(out$time, out$incidence,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence journalière")
```

a, B_MH, b_HM, NM pas identifiables (juste leur combi)

# Asympto E divisé en I et A
```{r}
SEIAR_SEI <- function(t, state, parameters) {

  with(as.list(c(state, parameters)), {

    # Forces d'infection
    lambda_H <- a * b_MH * I_M / N_H
    lambda_M <- a * b_HM * (I_H + theta * A_H) / N_H

    # Humains
    dS_H <- -lambda_H * S_H
    dE_H <-  lambda_H * S_H - sigma_H * E_H
    dI_H <-  p * sigma_H * E_H - gamma_I * I_H
    dA_H <- (1 - p) * sigma_H * E_H - gamma_A * A_H
    dR_H <-  gamma_I * I_H + gamma_A * A_H

    # Moustiques
    dS_M <-  mu_M * N_M - lambda_M * S_M - mu_M * S_M
    dE_M <-  lambda_M * S_M - sigma_M * E_M - mu_M * E_M
    dI_M <-  sigma_M * E_M - mu_M * I_M

    list(c(
      dS_H, dE_H, dI_H, dA_H, dR_H,
      dS_M, dE_M, dI_M
    ))
  })
}

```

```{r}
parameters <- c(
  
  # Taille pop
  N_H = 55000,
  N_M = 30000, #?

  p     = 0.2,    # proportion symptomatique
  theta = 0.7,    # infectiosité asympto
  
  # Transmission
  a     = 0.5,      # piqûres / moustique / jour
  b_MH  = 0.3,      # moustique -> humain
  b_HM  = 0.3,      # humain -> moustique

  # Humains
  sigma_H = 1/5,    # durée incubation humaine : 5j
  gamma_I = 1/7,
  gamma_A = 1/7,    # durée infection : 4.7j

  # Moustiques
  sigma_M = 1/10,   # durée incubation : 10j ?
  mu_M    = 1/15    # durée vie : 10j ?
)

```

```{r}
init <- c(
  S_H = as.numeric(parameters["N_H"]) - 1,
  E_H = 0,
  I_H = 1,
  A_H = 0,
  R_H = 0,

  S_M = as.numeric(parameters["N_M"]),
  E_M = 0,
  I_M = 0
)

times <- seq(0, 146, by = 1) # mettre + long 
```

```{r}
out <- ode(
  y = init,
  times = times,
  func = SEIAR_SEI,
  parms = parameters,
  method = "rk4"
)

out <- as.data.frame(out)
```

```{r}
out$incidence <- parameters["sigma_H"] * out$E_H
```

```{r}
plot(out$time, out$incidence * 55000*0.2,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence journalière")
lines(date$cases)
```

# Sans les moustiques avec Asympto E divisé en I et A
```{r}
SEIAR <- function(t, state, parameters) {

  with(as.list(c(state, parameters)), {

    # Forces d'infection integrant moustiques
    lambda_H <- beta * (I_H + theta * A_H) / N_H

    # Humains
    dS_H <- -lambda_H * S_H
    dE_H <-  lambda_H * S_H - sigma_H * E_H
    dI_H <-  p * sigma_H * E_H - gamma_I * I_H
    dA_H <- (1 - p) * sigma_H * E_H - gamma_A * A_H
    dR_H <-  gamma_I * I_H + gamma_A * A_H

    list(c(
      dS_H, dE_H, dI_H, dA_H, dR_H
    ))
  })
}

```

```{r}
parameters <- c(
  
  # Taille pop
  N_H = 55000,

  # Transmission 
  beta = 0.5, #A MODIFIER !!!!

  # Humains
  sigma_H = 1/5,
  gamma_I = 1/7,
  gamma_A = 1/7,

  p     = 0.2,   # proportion symptomatique
  theta = 0.7    # infectiosité asympto
)

init <- c(
  S_H = as.numeric(parameters["N_H"]) - 1,
  E_H = 0,
  I_H = 1,
  A_H = 0,
  R_H = 0
)

times <- seq(0, 146, by = 1) # mettre + long 
```

```{r}
out <- ode(
  y = init,
  times = times,
  func = SEIAR,
  parms = parameters,
  method = "rk4"
)

out <- as.data.frame(out)
```

Incidence : 
```{r}
# Incidence : nbr nvlles infections par intervalle de tps 
# sigma x E (nbr indiv qui passent de E à I par jour)
# Incidence en nbr indiv/jours
out$incidence <- parameters["sigma_H"] * out$E_H

# Cas observés : nbr de cas détectés par jour 
taux_detec <- 1 #le faire varier : début infection (X%) vs fin infcetion (100%)
out$incidence_obs <- taux_detec * parameters["p"] * out$incidence
out$cumule <- cumsum(out$incidence_obs)

out <- cbind(out, tt_data)
```

```{r}
plot(out$time, out$incidence_obs,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence journalière")
lines(out$time+40, tt_data$cases)

plot(out$time, out$cumule,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence cumulée")
lines(out$time, tt_data$cumule)
```
Décalage des dates !!! On a pas le début de l'épidémie

```{r}
indic_week <- tapply(out$incidence_obs, floor(out$time/7), sum)

plot(data_sem$week, indic_week,
     type = "l", lwd = 2,
     xlab = "Temps (semaine depuis le début de l'étude)",
     ylab = "Incidence hebdomadaire")
lines(data_sem$week, data_sem$cases)
```

```{r}
outA <- ode(
  y = init,
  times = times,
  func = SEIAR_SEI,
  parms = parameters,
  method = "rk4"
)

outA <- as.data.frame(outA)
```

```{r}
outA$incidence <- parameters["sigma_H"] * outA$E_H
```

```{r}
plot(outA$time, outA$incidence*55000*0.2,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence journalière")

```


# Inférence des paramètres : ABC rejection
Critère à optimiser : Somme des carrés des écarts (incidence à la fin de l'épidémie + incidence cumulée)
La SSE pénalise fortement les écarts importants, ce qui la rend sensible aux valeurs aberrantes. Elle est adaptée lorsque les erreurs sont supposées suivre une distribution normale.   
Si distribution non normale : erreur absolue moyenne (MAE)    

```{r}
stat_resum_data <- data.frame(dist_cumul = sum(data$cases), #inicidence cumulée
  dist_incidence = data$cases[101], #incidence au dernier jour
  max_pic = max(data$cases),
  temp_pic = which.max(data$cases))
```

```{r}
T = 1000

df_param <- data.frame(
  # Stat résumées : 
  dist_cumul = rep(NA, T), 
  dist_incidence = rep(NA, T),
  cumul = rep(NA,T),
  max_pic = rep(NA,T),
  temp_pic = rep(NA,T),
  # Priors testés : 
  beta = runif(T, min = 0, max = 0.5),
  theta = runif(T, min = 0, max = 1.5),
  p = runif(T, min = 0.1, max = 0.8) #monter de 0.1 à 0.8 (c'est bcp, mais on teste)
)

#df_serie <- data.frame(nrows = 147)

for (i in 1:T){
  
  # Echantillonnage des param --------------------------------------------------
  parameters <- c(
  N_H = 55000,
  beta = df_param[i,]$beta,
  sigma_H = 1/5.7, #
  gamma_I = 1/4.7,
  gamma_A = 1/4.7,
  p = df_param[i,]$p,
  theta = df_param[i,]$theta)
  
  # Simulation des données -----------------------------------------------------
  out <- ode(
  y = init,
  times = times,
  func = SEIAR,
  parms = parameters,
  method = "rk4")
  
  # Cacul des stat résumées ----------------------------------------------------
  out <- as.data.frame(out)
  out$incidence <- parameters["sigma_H"] * out$E_H * parameters["p"] # durée incubation x nbr d'exposés x proba symptomatique 
  out$cumsum <- cumsum(out$incidence)
  
  # Calcul de la distance ------------------------------------------------------
  df_param[i,]$cumul <- out$cumsum[147]
  df_param[i,]$dist_cumul <- ((out$cumsum[147]-stat_resum_data$dist_cumul)^2)/(stat_resum_data$dist_cumul^2) # ~1000
  df_param[i,]$dist_incidence <- ((out$incidence[147]-stat_resum_data$dist_incidence)^2)/(stat_resum_data$dist_incidence^2) # ~1
  df_param[i,]$max_pic <- ((max(out$incidence) - stat_resum_data$max_pic)^2)/(stat_resum_data$max_pic^2)
  df_param[i,]$temp_pic <- ((which.max(out$incidence) - stat_resum_data$temp_pic)^2)/(stat_resum_data$temp_pic^2)
  
  #df_serie <- cbind(df_serie, out$incidence)
  print(i)
}

# Distance SCE -----------------------------------------------------------------
# Distance euclidienne : 
df_param$dist_carre <- df_param$dist_cumul + df_param$dist_incidence + df_param$max_pic #+ df_param$temp_pic
df_param = df_param[order(df_param$dist_carre, decreasing = FALSE),] # ranger les erreurs


df_subset <- df_param[c(1:500),c("beta","theta","p")] # garder les 500 meilleurs
ggpairs(df_subset)

setDT(df_param)
df_cumul_tronc <- df_param[cumul<5000]
ggplot(data = df_cumul_tronc)+
  geom_point(x=df_cumul_tronc[,p], y= df_cumul_tronc[,beta], color = df_cumul_tronc[,cumul])
```

Si on prend le cumul à la fin, c'est pas grave si on a pas le début de l'épidémie. On voit dans nos données qu'il y a presque aucun nouveau cas à la fin. 

Calcul de la distribution a prosteriori : 
```{r}
i=1

parameter_closest <- c(
  N_H = 55000,
  beta = 0.27,
  sigma_H = 1/5.7,
  gamma_I = 1/4.7,
  gamma_A = 1/4.7,
  p = 0.4,
  theta = 1.3048)

out_close <- ode(
  y = init,
  times = times,
  func = SEIAR,
  parms = parameter_closest,
  method = "rk4")

out_close <- as.data.frame(out_close)
out_close$incidence <- parameter_closest["sigma_H"] * out_close$E_H * parameter_closest["p"]
out_close$cumule <- cumsum(out_close$incidence)
#data$cumule <- cumsum(data$cases)

plot(out_close$cumule, col = "blue")
lines(data$cumule, col = "red")

plot(out_close$incidence, col = "blue")
lines(data$cases, col = "red")
```

Bon ça marche pas top, peut être que l'exploration de l'espace des paramètres est pas top ? ou la distance choisie.ou les summary stat

```{r}
Tol = 0.1

test_abc_n <- abc(target = c(928,1), param = df_param[,.(beta,theta,p)], sumstat =df_param[,.(dist_cumul,dist_incidence)], tol = Tol , method = "neuralnet")

summary(test_abc_n)
hist(test_abc_n)
plot(test_abc_n, param = df_param[,.(beta,theta,p)])
```

## ABC SMC 
Je tente autre méthode (pas encore prêt à faire tourner)

```{r}
# Distributions a priori uniformes pour beta theta et p
priors <- list(
  beta = list(dist = "unif", min = 0, max = 1),
  theta = list(dist = "unif", min = 0, max = 1.5),
  p = list(dist = "unif", min = 0, max = 1)
)
```

```{r}
# Fonction pour calculer les statistiques résumés
summary_stats <- function(data) {
  return(data$I)
}

# Calcul des statistiques résumés observés
summary_obs <- summary_stats(data.frame(I = I_obs))

# Fonction de distance (somme des carrés des différences)
distance_function <- function(summary_sim, summary_obs) {
  return(sum((summary_sim - summary_obs)^2))
}
```

