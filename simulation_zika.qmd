---
title: "Modélisation de l'épidemie de Zika à San Andres en 2015"
date: "`r Sys.Date()`"
author: "Capucine Benoit-Grignard, Maite Decencière"
format:
  html:
    toc: true
    toc-floating: true
    number-sections: true
    code-fold: true
    embed-resources: true
    toc-depth: 4
    theme: cosmo
    highlight-style: pygments
    fig.align: center
---

# Packages
```{r, message = FALSE, warning = FALSE}
rm(list = ls())

# Installation des packages s'ils ne sont pas installés ------------------------
requiredPackages <- c("outbreaks", "lubridate", "dplyr", "data.table", "readr", 
                      "deSolve", "abc", "ggplot2", "grid", "gridExtra",
                      "ggpubr", "GGally", "devtools", "tidyr")
for(package in requiredPackages){ 
  if(!requireNamespace(package, quietly = TRUE))
    install.packages(package)
}
if(!requireNamespace("BRREWABC")){install_github("gaelbn/BRREWABC")}

## Packages dont sont issues les données ---------------------------------------
library(outbreaks)

## Packages pour la gestion des données ----------------------------------------
library(lubridate)  # Gestion des dates 
library(dplyr)      # Gestion des data.frame
library(tidyr)      # Gestion des data.frame
library(data.table) # Gestion des data.frame
library(readr)      # Lecture fichier .txt / .csv

## Packages pour la simulation / l'inférence / l'ABC ---------------------------
library(deSolve)    # Resultion d'équations différentielles
library(abc)        # Méthode d'ABC rejection et cross validation
library(BRREWABC)

## Packages graphiques ---------------------------------------------------------
library(ggplot2)   # Graphiques 
library(grid)      # Rearrange les figures
library(gridExtra) # Rearrange les figures
library(ggpubr)    # Rearrange les figures
library(GGally)

library(devtools)

## Reproductibilité des données ------------------------------------------------
set.seed(23) 
```

# Données 
Données d'incidence journalière de l'épidémie de Zika, survenue sur l'ile de San Andres en 2015, issues du package `outbreaks` (Jombart et al., 2020) et publiées par les auteurs de l'article Rojas (2015). 
```{r}
data <- zika_sanandres_2015
data$cumule <- cumsum(data$cases) # incidence cumulée
data$cases_ajuste <- data$cases
```

```{r}
plot(data, pch = 19)
plot(x = data$date, y = data$cumule)

ggplot(data, aes(x = date, y = cases))+
  geom_line() + 
  geom_point(alpha = 0.7) +
  theme_bw()
```

## Rajouter les pas de temps manquants (avec des NA)
Pour avoir la bonne taille de data.frame en terme de nombre de jours (par rapport à la simulation), il est nécessaire de rajouter les jours manquants. L'incidence pour ces jours sera `NA`. 
```{r}
tt_data <- seq(from = min(data$date), to = max(data$date), by = "day")
tt_data <- data.frame(date = tt_data) %>%
  left_join(., data, by = "date") %>%
  mutate(week = floor(as.numeric(date - min(date))/7))
```

## Données d'incidence hebdomadaire depuis le début de suivi
```{r}
data_sem <- tt_data %>%
  group_by(week) %>%
  summarize(cases = sum(cases, na.rm = TRUE)) %>% #incidence hebdomadaire
  mutate(cumule = cumsum(cases)) #incidence hebdomadaire cumulée
```

```{r}
a <- data_sem %>% 
  ggplot(., aes(x = week, y = cases)) + 
  geom_line(color = "black", lwd = 0.8) + 
  geom_point(color = "black", alpha = 0.5, size = 2.5) +
  geom_hline(yintercept = 0, col = "black") + 
  theme_bw() + 
  theme(axis.title = element_text(size = 15), legend.position = "none", 
        axis.text = element_text(size = 14)) +
  xlab("Durée de l'épidemie (en semaines)") + 
  ylab("Incidence hebdomadaire (nombre de nouveaux cas)")

b <- data_sem %>% 
  ggplot(., aes(x = week, y = cumule)) + 
  geom_line(color = "black", lwd = 0.8) + 
  geom_point(color = "black", alpha = 0.5, size = 2.5) +
  geom_hline(yintercept = 0, col = "black") + 
  theme_bw() + 
  theme(axis.title = element_text(size = 15), legend.position = "none", 
        axis.text = element_text(size = 14)) +
  xlab("Durée de l'épidemie (en semaines)") + 
  ylab("Incidence hebdomadaire cumulée (nombre de nouveaux cas)")

ggarrange(a, b)
```

## Données météorologiques 
Données de température et de pluviométrie horaire sur la zone d'étude entre septembre 2015 et février 2016, issues de la base de données ERA5 
```{r}
meteo <- read.csv("era5.csv")

data_sem_meteo <- meteo %>%
  mutate(valid_time = as.POSIXct(valid_time),
         day = as_date(valid_time), 
         week = floor(as.numeric(day - min(day))/7)) %>%
  group_by(week) %>%
  ## Conditions météorologiques moyennes, maximales et minimales par semaine
  summarize(tp_mean = mean(tp, na.rm = TRUE), 
            sst_mean = mean(sst, na.rm = TRUE), 
            tp_min = min(tp, na.rm = TRUE), 
            sst_min = min(sst, na.rm = TRUE), 
            tp_max = max(tp, na.rm = TRUE), 
            sst_max = max(sst, na.rm = TRUE)) %>%
  left_join(., data_sem, by = "week")

data_sem_meteo %>% 
  ggplot(., aes(x = week, y = cases)) + 
  # geom_line(color = "black", lwd = 0.8) + 
  # geom_point(color = "black", alpha = 0.5, size = 2.5) +
  geom_line(aes(y = tp_mean), col = "red") +
  geom_ribbon(aes(ymin = tp_min, ymax = tp_max), fill = "red", alpha = 0.3) + 
  geom_hline(yintercept = 0, col = "black") + 
  theme_bw() + 
  theme(axis.title = element_text(size = 15), legend.position = "none", 
        axis.text = element_text(size = 14)) +
  xlab("Durée de l'épidemie (en semaines)") + 
  ylab("Incidence hebdomadaire (nombre de nouveaux cas)")
```

```{r}
# data %>%
#   left_join(., era5, by = c("date" = "valid_time"))
```

# Modèle SEAIR
Modèle SEAIR avec cinq compartiments sur une seule population humaine
```{r}
SEIAR <- function(t, state, parameters) {

  with(as.list(c(state, parameters)), {

    # Forces d'infection integrant moustiques
    lambda_H <- beta * (I_H + theta * A_H) / N_H

    # Humains
    dS_H <- -lambda_H * S_H                         # Individus susceptibles                  
    dE_H <-  lambda_H * S_H - sigma_H * E_H         # Individus exposés 
    dI_H <-  p * sigma_H * E_H - gamma_I * I_H      # Individus infectés
    dA_H <- (1 - p) * sigma_H * E_H - gamma_A * A_H # Individus asymptomatiques
    dR_H <-  gamma_I * I_H + gamma_A * A_H          # Individus rétablis

    list(c(dS_H, dE_H, dI_H, dA_H, dR_H))
  })
}
```

Paramètres du modèle : 
```{r}
parameters <- c(
  
  # Taille de population
  N_H = 54500,

  # Transmission 
  beta = 0.5, 

  # Humains
  sigma_H = 1/5.7, # taux d'incubation : 1/ durée incubation
  gamma_I = 1/4.7, # taux de guérison des symptomatqiues : 1/ duree infection
  gamma_A = 1/4.7, # taux de guérison des asymptomatqiues : 1/ duree infection

  p     = 0.2,   # proportion d'inidvidus symptomatiques dans la population
  theta = 0.7    # infectiosité relative des asymptomatiques
)

## Conditions initiales de la simulation  --------------------------------------
init <- c(
  S_H = as.numeric(parameters["N_H"]) - 1, # Toute la population est suscpetible (sauf le patient 0)
  E_H = 1,                                 # 1 seule personne exposée dans la population 
  I_H = 0,
  A_H = 0,
  R_H = 0
)

## Durée de la simulation ------------------------------------------------------
times_obs <- seq(0, 146, by = 1)
times_sim <- seq(0, 500, by = 1)
```

# Inférence du modèle avec des paramètres fixés 
```{r}
out <- ode(
  y = init,
  times = times_sim,
  func = SEIAR,
  parms = parameters,
  method = "rk4"
)

out <- as.data.frame(out)
```

Incidence :   
Nombre de nouvelles infections par intervalle de temps    
$Incidence = \sigma * E$ (nbr indiv qui passent de E à I par jour)
```{r}
# Incidence en nbr indiv/jours
out$incidence <- parameters["sigma_H"] * out$E_H

# Cas observés : nbr de cas détectés par jour 
taux_detec <- 1  # le faire varier : début infection (X%) vs fin infcetion (100%)
out$incidence_obs <- taux_detec * parameters["p"] * out$incidence
out$cumule <- cumsum(out$incidence_obs)

out <- cbind(out, tt_data)
```

```{r}
plot(out$times_sim, out$incidence_obs,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence journalière")
lines(out$time+40, tt_data$cases)

plot(out$times_sim, out$cumule,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence cumulée")
lines(out$times_sim, tt_data$cumule)
```
Décalage des dates !!! On a pas le début de l'épidémie

```{r}
indic_week <- tapply(out$incidence_obs, floor(out$time/7), sum)

plot(data_sem$week, indic_week,
     type = "l", lwd = 2,
     xlab = "Temps (semaine depuis le début de l'étude)",
     ylab = "Incidence hebdomadaire")
lines(data_sem$week, data_sem$cases)
```

```{r}
outA <- ode(
  y = init,
  times = times_sim,
  func = SEIAR_SEI,
  parms = parameters,
  method = "rk4"
)

outA <- as.data.frame(outA)
```

```{r}
outA$incidence <- parameters["sigma_H"] * outA$E_H
```

```{r}
plot(outA$time_sim, outA$incidence*55000*0.2,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence journalière")

```

# Inférence des paramètres par ABC rejection
## Fonction de simulation du modèle
```{r}
simul <- function(T, beta_p, theta_p, p_p){
  ## FONCTION QUI : 
  # Simule T fois le modèle SEAIR avec des valeurs de paramètres p, beta et theta fixés ou tirés dans une distribution a priori
  # Calcule une distance MAE entre les incidences simulées et celles observées 
  # Classe les simulations selon la MAE la plus faible
  ## ENTREE : 
  # T : Nombre de simulations (souvent 10 000)
  # T valeurs de beta, theta et p (soit issues de distributions a priori, soit des valeurs fixées)
  ## SORTIE : 
  # Tableau df_subset avec des paramètres tirés dans chaque simualtion, avec la 
  # valeur de distance associée (MAE)
  
  ## Construction du dataframe des simulations ---------------------------------
  df_param <- data.frame(
    ## Statistiques résumées : 
    # SCE = rep(NA, T),
    MAE = rep(NA, T),
    ## Priors testés : 
    beta = beta_p, 
    theta = theta_p, 
    p = p_p 
  )
  
  for (i in 1:T){
    
    # Echantillonnage des paramètres -------------------------------------------
    parameters <- c(
      N_H = 54500,               # taille de population
      beta = df_param[i,]$beta,
      sigma_H = 1/5.7,           # selon biblio
      gamma_I = 1/4.7,           # selon biblio
      gamma_A = 1/4.7,           # selon biblio
      p = df_param[i,]$p,
      theta = df_param[i,]$theta)
    
    # Simulation des données -----------------------------------------------------
    out <- ode(
      y = init,
      times = times_sim, #sur le temps du modele : + long 
      func = SEIAR,
      parms = parameters,
      method = "rk4")
    
    # Calcul incidence ---------------------------------------------------------
    out <- as.data.frame(out)
    out$incidence <- parameters["sigma_H"] * out$E_H * parameters["p"] # durée incubation x nbr d'exposés x   proba symptomatique 
    
    # Remettre les data au même niveau que le modèle : décalage temporel -------
    # Prendre 1er temps où inicidence obs = 1 (1er cas)
    t_align <- which(out$incidence >= 1)[1] 
    
    # si t_align = NA : jamais inicidence de 1, on n'enregistre pas la simulation 
    if(!is.na(t_align)){
      out <- out[t_align:(t_align + nrow(tt_data) - 1), ] # prendre 147 jours après le 1er cas détecté par le   modèle
      out <- cbind(out, tt_data) # jointure avec le tableau des données observées 
    
      out_week <- out %>%
        mutate(week = floor(as.numeric(date - min(date))/7)) %>% # création des semaines 
        group_by(week) %>%
        summarize(cases_obs = sum(cases, na.rm = TRUE),          # somme incidence par semaine observée 
                  cases_sim = sum(incidence, na.rm = TRUE)) %>%  # somme incidence par semaine simulée
        ungroup() %>%
        arrange(week) %>%
        mutate(cases_obs_cum = cumsum(cases_obs),                 # cumul pour chaque semaine 
              cases_sim_cum = cumsum(cases_sim))
    
    # Calcul de la distance ------------------------------------------------------
        dist <- out_week %>% 
         summarise(MAE = mean(abs(cases_obs_cum - cases_sim_cum))) # MAE sur l'incidence cumulée
      df_param[i,]$MAE <- dist$MAE
    }
      # print(i)
  }
  
  ## Ordination des simulations par valeurs de MAE -----------------------------
  df_param <- df_param[order(df_param$MAE, decreasing = FALSE),] 
  
  ## Conservation des 500 meilleures simulations -------------------------------
  df_subset <- df_param[c(1:500), c("beta","theta", "p", "MAE")]
  
  return(list(df_param, df_subset))
}

```

## Fonction de simulation du modèle avec la meilleure distance MAE
```{r}
meilleur_model_simul <- function(df_subset){
  # Fonction qui : 
  # Simule le modèle SEAIR avec les valeurs de paramètres p, theta et beta issue du modèle avec la MAE la plus faible
  ## ENTREE : 
  # Dataframe df_subset issu de la fonction simul : la 1ere ligne correspond aux valeurs 
  # de p, theta et beta du modèle avec la plus faible distance MAE
  ## SORTIE : 
  # Dataframe df_out avec les valeurs d'incidence simulée pour chaque pas de temps
  # avec les valeurs de paramètres p, theta et beta estimées à partir du modèle avec 
  # la MAE la plus faible
  
  ## Reordination au cas où de df_subset pour prendre le modèle avec la MAE la plus faible
  df_subset <- df_subset[order(df_subset$MAE, decreasing = FALSE),] 
  
  ## Choix de la 1ere meilleure simulation -------------------------------------
  i = 1

  ## Recupération des paramètres du meilleur modèle ----------------------------
  parameter_closest <- c(
    N_H = 54500,
    beta = df_subset[i,]$beta,
    sigma_H = 1/5.7,
    gamma_I = 1/4.7,
    gamma_A = 1/4.7,
    p = df_subset[i,]$p,
    theta = df_subset[i,]$theta)
  
  ## Simulation du modèle SEAIR ------------------------------------------------
  out_close <- ode(
    y = init,
    times = times_sim,
    func = SEIAR,
    parms = parameter_closest,
    method = "rk4")
  
  ## Calcul de l'incidence -----------------------------------------------------
  out_close <- as.data.frame(out_close)
  out_close$incidence <- parameter_closest["sigma_H"] * out_close$E_H * parameter_closest["p"]
  
  ## Remettre au bon pas de temps temporel -------------------------------------
  t_align <- which(out_close$incidence >= 1)[1]
  out_close_tempo <- out_close[t_align:(t_align + nrow(tt_data) - 1), ] # prendre 147 jours après le 1er cas   détecté par le modèle
  
  ## Lier avec le dataframe des données observées ------------------------------
  df_out <- cbind(out_close_tempo, tt_data) %>%
    group_by(week) %>% # somme par semaine
    summarize(cases_obs = sum(cases, na.rm = TRUE), 
              cases_sim = sum(incidence, na.rm = TRUE)) %>%
    mutate(cumule_obs = cumsum(cases_obs), 
           cumule_sim = cumsum(cases_sim))
  
  return(df_out)
}

```

```{r}
# write.table(df_param, "simul_beta_theta.csv", sep="t",dec=",", na=" ")
# write.table(df_param, "simul_p_theta.csv", sep="t",dec=",", na=" ")
# write.table(df_param, "simul_p_beta.csv", sep="t",dec=",", na=" ")

# df_param <- read.table("simul_beta_theta.csv", sep="t",dec=",", na=" ")
# df_param <- read.table("simul_p_beta.csv", sep="t",dec=",", na=" ")
# df_param <- read.table("simul_p_beta_theta.csv", sep="t",dec=",", na=" ")
# df_param <- read.table("simul_p_theta.csv", sep="t",dec=",", na=" ")
```

## p, theta et beta estimés
### Recherche du modèle avec les meilleurs paramètres
Les priors des 3 paramètres sont des distributions uniformes. 
```{r}
## Nombre de simulations -------------------------------------------------------
T <- 10000

## Priors ----------------------------------------------------------------------
beta_prior <- runif(T, min = 0, max = 3)
theta_prior <- runif(T, min = 0, max = 1) 
p_prior <- runif(T, min = 0.01, max = 0.8)

## 10000 simulations du modèle pour différentes valeurs de paramètres ----------
simu_resul <- simul(T,
                    beta_p = beta_prior, 
                    theta_p = theta_prior,
                    p_p = p_prior)

df_param <- simu_resul[[1]]
df_subset <- simu_resul[[2]]

# write.table(df_subset, "simul_p_beta_theta_sure.csv", sep="t",dec=",", na=" ")

## Simulation de l'incidence avec le meilleur modèle ---------------------------
df_out <- meilleur_model_simul(df_subset)
```

```{r, message=FALSE, warning = FALSE}
ggpairs(df_subset %>% dplyr::select(-MAE), 
        upper = list(continuous = wrap('cor', size = 14))) +
  theme_bw(base_size = 20) 
```

Comparaison visuelle avec les incidences observées
```{r}
plot(df_out$week, df_out$cumule_obs,  col = "blue")
lines(df_out$cumule_sim, col = "red")

plot(df_out$week, df_out$cases_obs,  col = "blue")
lines(df_out$cases_sim, col = "red")

plot(df_out$cases_sim)
plot(df_out$cumule_sim)
```

### Cross validation des paramètres
```{r}
setDT(df_param)

cv_zika <- cv4abc(param = df_param[, .(theta, beta, p)],
                  sumstat = df_param[, MAE], nval = 500,
                  tols = c(0.05), method = "rejection")

plot(cv_zika)
summary(cv_zika)
```
Très mauvais pour beta et theta

### ABC rejection
```{r}
## Seuil de tolérance : 
Tol = 0.1
setDT(df_param) # passage en data.table

## ABC rejection ---------------------------------------------------------------
test_abc_n <- abc(target = c(0), 
                  param = df_param[,.(beta, p, theta)],
                  sumstat = df_param[,MAE], 
                  tol = Tol , method = "rejection")

summary(test_abc_n)
hist(test_abc_n)
# plot(test_abc_n, param = df_param[,.(beta,theta,p)])
```

## p fixé à 0.04, theta et beta estimés
```{r}
p_prior <- rep(0.04, T)
beta_prior <- runif(T, min = 0, max = 3)
theta_prior <- runif(T, min = 0, max = 1) 

## 10000 simulations du modèle pour différentes valeurs de paramètres ----------
simu_resul <- simul(T,
                    beta_p = beta_prior, 
                    theta_p = theta_prior,
                    p_p = p_prior)

df_param_pfixe <- simu_resul[[1]]
df_subset_pfixe <- simu_resul[[2]]
# write.table(df_subset_pfixe, "simul_beta_theta.csv", sep="t",dec=",", na=" ")

## Simulation de l'incidence avec le meilleur modèle ---------------------------
df_out_pfixe <- meilleur_model_simul(df_subset_pfixe)
```

```{r}
ggpairs(df_subset_pfixe %>% dplyr::select(-MAE),
        upper = list(continuous = wrap('cor', size = 14))) +
  theme_bw(base_size = 20) 
```

Comparaison visuelle avec les incidences observées
```{r}
plot(df_out_pfixe$week, df_out_pfixe$cumule_obs,  col = "blue")
lines(df_out_pfixe$cumule_sim, col = "red")

plot(df_out_pfixe$week, df_out_pfixe$cases_obs,  col = "blue")
lines(df_out_pfixe$cases_sim, col = "red")

plot(df_out_pfixe$cases_sim)
plot(df_out_pfixe$cumule_sim)
```

### Cross validation des paramètres
```{r}
setDT(df_param_pfixe)

cv_zika <- cv4abc(param = df_param_pfixe[, .(theta, beta)],
                  sumstat = df_param_pfixe[, MAE], nval = 500,
                  tols = c(0.05), method = "rejection")

plot(cv_zika)
summary(cv_zika)
```
Moins mauvais pour beta et theta, mais toujours mauvais

### ABC rejection
```{r}
## Seuil de tolérance : 
Tol = 0.1
setDT(df_param_pfixe) # passage en data.table

test_abc_pfixe <- abc(target = c(0), 
                  param = df_param_pfixe[,.(beta, theta)],
                  sumstat = df_param_pfixe[,MAE], 
                  tol = Tol , method = "rejection")

summary_abc_pfixe <- summary(test_abc_pfixe)
summary_abc_pfixe
hist(test_abc_pfixe)
```

## theta fixé, p et beta estimés
```{r}
theta_prior <- rep(0.7, T)
beta_prior <- runif(T, min = 0, max = 3)
p_prior <- runif(T, min = 0.01, max = 0.8)

## 10000 simulations du modèle pour différentes valeurs de paramètres ----------
simu_resul <- simul(T,
                    beta_p = beta_prior, 
                    theta_p = theta_prior,
                    p_p = p_prior)

df_param_thetafixe <- simu_resul[[1]]
df_subset_thetafixe <- simu_resul[[2]]
# write.table(df_subset_thetafixe, "simul_beta_p.csv", sep="t",dec=",", na=" ")

## Simulation de l'incidence avec le meilleur modèle ---------------------------
df_out_thetafixe <- meilleur_model_simul(df_subset_thetafixe)
```

```{r}
ggpairs(df_subset_thetafixe %>% dplyr::select(-MAE),
        upper = list(continuous = wrap('cor', size = 14))) +
  theme_bw(base_size = 20) 
```

Comparaison visuelle avec les incidences observées
```{r}
plot(df_out_thetafixe$week, df_out_thetafixe$cumule_obs,  col = "blue")
lines(df_out_thetafixe$cumule_sim, col = "red")

plot(df_out_thetafixe$week, df_out_thetafixe$cases_obs,  col = "blue")
lines(df_out_thetafixe$cases_sim, col = "red")

plot(df_out_thetafixe$cases_sim)
plot(df_out_thetafixe$cumule_sim)
```

### Cross validation des paramètres
```{r}
setDT(df_param_thetafixe)

cv_zika <- cv4abc(param = df_param_thetafixe[, .(p, beta)],
                  sumstat = df_param_thetafixe[, MAE], nval = 500,
                  tols = c(0.05), method = "rejection")

plot(cv_zika)
summary(cv_zika)
```
Très mauvais pour beta et theta

### ABC rejection
```{r}
## Seuil de tolérance : 
Tol = 0.1
setDT(df_param_pfixe) # passage en data.table

test_abc_n <- abc(target = c(0), 
                  param = df_param_thetafixe[,.(beta, p)],
                  sumstat = df_param_thetafixe[,MAE], 
                  tol = Tol , method = "rejection")

summary(test_abc_n)
hist(test_abc_n)
plot(test_abc_n, param = df_param_pfixe[,.(beta,p)])
```

## beta fixé, p et theta estimés 
```{r}
beta_prior <- rep(0.5, T)
p_prior <- runif(T, min = 0.01, max = 0.8)
theta_prior <- runif(T, min = 0, max = 1) 

## 10000 simulations du modèle pour différentes valeurs de paramètres ----------
simu_resul <- simul(T,
                    beta_p = beta_prior, 
                    theta_p = theta_prior,
                    p_p = p_prior)

df_param_betafixe <- simu_resul[[1]]
df_subset_betafixe <- simu_resul[[2]]
# write.table(df_param_betafixe, "simul_p_theta.csv", sep="t",dec=",", na=" ")

## Simulation de l'incidence avec le meilleur modèle ---------------------------
df_out_betafixe <- meilleur_model_simul(df_subset_betafixe)
```

```{r}
ggpairs(df_subset_betafixe %>% dplyr::select(-MAE),
        upper = list(continuous = wrap('cor', size = 14))) +
  theme_bw(base_size = 20) 
```

Comparaison visuelle avec les incidences observées
```{r}
plot(df_out_betafixe$week, df_out_betafixe$cumule_obs,  col = "blue")
lines(df_out_betafixe$cumule_sim, col = "red")

plot(df_out_betafixe$week, df_out_pfixe$cases_obs,  col = "blue")
lines(df_out_betafixe$cases_sim, col = "red")

plot(df_out_betafixe$cases_sim)
plot(df_out_betafixe$cumule_sim)
```

### Cross validation des paramètres
```{r}
setDT(df_param_betafixe)

cv_zika <- cv4abc(param = df_param_betafixe[, .(theta, p)],
                  sumstat = df_param_betafixe[, MAE], nval = 500,
                  tols = c(0.05), method = "rejection")

plot(cv_zika)
summary(cv_zika)
```
Très mauvais pour beta et theta

### ABC rejection
```{r}
## Seuil de tolérance : 
Tol = 0.1
setDT(df_param_betafixe) # passage en data.table

test_abc_n <- abc(target = c(0), 
                  param = df_param_betafixe[,.(p, theta)],
                  sumstat = df_param_betafixe[,MAE], 
                  tol = Tol , method = "rejection")

summary(test_abc_n)
hist(test_abc_n)
plot(test_abc_n, param = df_param_betafixe[,.(p,theta)])
```

## Comparaison des dynamiques avec différents paramètres fixés ou estimés 
```{r}
tout <- rbind(df_out %>% mutate(simu = "p_beta_theta"), 
              df_out_pfixe %>% mutate(simu = "theta_beta")) #, 
              # df_out_betafixe %>% mutate(simu = "theta_p"),
              # df_out_thetafixe %>% mutate(simu = "p_beta"))
# write.csv(tout, "tout.csv")

a <- tout %>% 
  group_by(simu) %>%
  ggplot(aes(x = week, y = cases_sim, col = simu), alpha = 0.5) +
  geom_line(lwd = 1) + 
  geom_line(aes(y = tout$cases_obs), color = "black", lwd = 0.8) + 
  geom_point(aes(y = tout$cases_obs), color = "black", alpha = 0.5, size = 2.5) +
  geom_hline(yintercept = 0, col = "black") + 
  theme_bw() + 
  theme(axis.title = element_text(size = 15), 
        legend.position = "none", 
        axis.text = element_text(size = 14)) +
  xlab("Durée de l'épidemie (en semaines)") + 
  ylab("Incidence hebdomadaire (nombre de nouveaux cas)") +
  labs(color = "Incidence simulée") + 
  ylim(c(0, 200))

b <- tout %>% 
  group_by(simu) %>%
  ggplot(., aes(x = week, y = cumule_sim, col = simu)) +
  geom_line(lwd = 1) + 
  # geom_line(aes(y = df_out_beta_theta$cumule_sim), lty = 3) +
  geom_line(aes(y = tout$cumule_obs), color = "black", lwd = 0.8) + 
  geom_point(aes(y = tout$cumule_obs), color = "black", alpha = 0.5, size = 2.5) + 
  geom_hline(yintercept = 0, col = "black") + 
  theme_bw() + 
  theme(axis.title = element_text(size = 15), 
        legend.text = element_text(size = 15), 
        legend.title = element_text(size = 16), 
        axis.text = element_text(size = 14)) + 
  xlab("Durée de l'épidemie (en semaines)") + 
  ylab("Incidence hebdomadaire cumulée (nombre de nouveaux cas)") +
  labs(color = "Incidence simulée") +
  ylim(c(0, 1500))

ggarrange(a, b)
```

# Calcul de R0 à partir de la Matrice de Prochaine Generation
Ici, le R0 correspond à la somme des contributions à la transmission des individus symptomatiques I et asymptomatiques A dans une population entièrement susceptible.    
**La matrice F de nouvelles infections :**   
$$ F = \begin{bmatrix}
\beta \frac{I+\theta A}{N} S \\
0 \\
0 \\
\end{bmatrix}
$$

**La matrice V des transitions hors des compratiments infectieux :**   
$$ V = \begin{bmatrix}
\delta E \\
p \delta E - \gamma_I I \\
(1-p) \delta E - \gamma_A A
\end{bmatrix}
$$
$$F = [\frac{\delta F_i}{\delta x_j}] = \begin{bmatrix}
0 & \beta \frac{S}{N} & \beta \theta \frac{S}{N} \\
0 & 0 & 0 \\
0 & 0 & 0 \\
\end{bmatrix}
$$
$$V = [\frac{\delta V_i}{\delta x_j}] = \begin{bmatrix}
\delta & 0 & 0 \\
p \delta & -\gamma_I & 0 \\
(1-p)\delta & 0 & -\gamma_A \\
\end{bmatrix}
$$

**Linéarisation au point d'équilibre (S*, E*, I*, A*, R*) = (N, 0, 0, 0, 0):**  
$$F_{DFE} = \begin{bmatrix}
0 & \beta & \beta \theta \\
0 & 0 & 0 \\
0 & 0 & 0
\end{bmatrix}
$$
$$V_{DFE} = \begin{bmatrix}
\delta & 0 & 0 \\
p \delta & -\gamma_I & 0 \\
(1-p)\delta & 0 & -\gamma_A \\
\end{bmatrix}
$$

**Matrice de prochaine génération :**   
$$
K = FV^{-1} = \begin{bmatrix}
0 & \beta & \beta \theta \\
0 & 0 & 0 \\
0 & 0 & 0
\end{bmatrix} 
\begin{bmatrix}
\frac{1}{\delta} & 0 & 0 \\
\frac{p}{\gamma_I} & -\frac{1}{\gamma_I} & 0 \\
\frac{1-p}{\gamma_A} & 0 & -\frac{1}{\gamma_A} \\
\end{bmatrix} = 
\begin{bmatrix}
\beta(\frac{p}{\gamma_I}+\frac{(1-p)\theta}{\gamma_A} & -\frac{\beta}{\gamma_I} & -\frac{\beta\theta}{\gamma_A} \\
0&0&0\\
0&0&0
\end{bmatrix}
$$

**R0 : ** 
$$R_0 = \rho(K) =  \beta(\frac{p}{\gamma_I}+\frac{(1-p)\theta}{\gamma_A})$$

```{r}
calcul_R0 <- function(beta, p, gamma_I, theta, gamma_A){
  ## Fonction qui calcule la valeur de R0 à partir de valeurs de paramètres 
  ## ENTREE : valeurs des paramètres 
  ## SORTIE : valeur de R0
  R0 <- beta * ((p/gamma_I) + ((1-p) * theta) / gamma_A)
    return(R0)
}
```

Calcul avec les modes des valeurs estimées par ABC : 
```{r}
R0 <- calcul_R0(beta = 0.542, p = 0.04, gamma_I = 1/4.7, theta = 0.14, gamma_A = 1/4.7)
```

Calcul avec les valeurs de l'ABC 
```{r}
p = 0.04
gamma_I = 1/4.7
gamma_A = 1/4.7

summary_abc_pfixe <- data.frame(summary_abc_pfixe) %>%
  pivot_wider(names_from = "Var2", values_from = "Freq") %>%
  rowwise() %>%
  mutate(R0 = calcul_R0(beta = beta, #valeur de beta estimée
                        p = p, #valeur de p fixée
                        gamma_I = gamma_I, #valeur de gamma fixée
                        theta = theta, #valeur de theta estimée
                        gamma_A = gamma_A)) #valeur de gamme fixée
```

