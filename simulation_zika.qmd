---
title: "Epidemie_Zika"
date: "`r Sys.Date()`"
format:
  html:
    toc: true
    toc-floating: true
    number-sections: true
    code-fold: true
    embed-resources: true
    toc-depth: 4
    theme: cosmo
    highlight-style: pygments
    fig.align: center
---

# Packages

```{r, message = FALSE, warning = FALSE}
library(outbreaks)
library(dplyr)
library(ggplot2)
library(deSolve)
library(abc)
library(ggplot2)
library(data.table)

# install.packages("devtools")
# Installer BRREWABC depuis GitHub
library(devtools)
# install_github("gaelbn/BRREWABC")
library(BRREWABC)
library(GGally)
```

# Data
```{r}
data <- zika_sanandres_2015
data$cumule <- cumsum(data$cases)
data$cases_ajuste <- data$cases
data[data]
```

```{r}
plot(data, pch = 19)
plot(x= data$date, y=data$cumule)

ggplot(data, aes(x = date, y = cases))+
  geom_line() + 
  geom_point(alpha = 0.7) +
  theme_bw()
```

## Rajouter les pas de temps manquants (avec des NA)
Pour avoir la bonne taille de data.frame (par rapport à la simulation)
```{r}
tt_data <- seq(from = min(data$date), to = max(data$date), by = "day")
tt_data <- data.frame(date = tt_data) %>%
  left_join(., data, by = "date") %>%
  mutate(week = floor(as.numeric(date - min(date))/7))
```

## Données en cumulées par semaine depuis le début de suivi
```{r}
data_sem <- tt_data %>%
  group_by(week) %>%
  summarize(cases = sum(cases, na.rm = TRUE)) %>%
  mutate(cumule = cumsum(cases))
```

## Données météo 
```{r}
# plot(as.Date(era5$valid_time), era5$tp)
# plot(as.Date(era5$valid_time), era5$sst)
```

```{r}
# data %>%
#   left_join(., era5, by = c("date" = "valid_time"))
```

# Sans les moustiques avec Asympto E divisé en I et A
```{r}
SEIAR <- function(t, state, parameters) {

  with(as.list(c(state, parameters)), {

    # Forces d'infection integrant moustiques
    lambda_H <- beta * (I_H + theta * A_H) / N_H

    # Humains
    dS_H <- -lambda_H * S_H
    dE_H <-  lambda_H * S_H - sigma_H * E_H
    dI_H <-  p * sigma_H * E_H - gamma_I * I_H
    dA_H <- (1 - p) * sigma_H * E_H - gamma_A * A_H
    dR_H <-  gamma_I * I_H + gamma_A * A_H

    list(c(
      dS_H, dE_H, dI_H, dA_H, dR_H
    ))
  })
}

```

```{r}
parameters <- c(
  
  # Taille pop
  N_H = 54500,

  # Transmission 
  beta = 0.5, 

  # Humains
  sigma_H = 1/5.7, # 1/ durée incubation
  gamma_I = 1/4.7, # 1/ duree infection
  gamma_A = 1/4.7,

  p     = 0.2,   # proportion symptomatique
  theta = 0.7    # infectiosité asympto
)
```


```{r}
init <- c(
  S_H = as.numeric(parameters["N_H"]) - 1,
  E_H = 1,
  I_H = 0,
  A_H = 0,
  R_H = 0
)

times_obs <- seq(0, 146, by = 1) # mettre + long 
times_sim <- seq(0, 500, by = 1) # mettre + long 
```

Test du modèle en changeant les paramètres à la main
```{r}
out <- ode(
  y = init,
  times = times,
  func = SEIAR,
  parms = parameters,
  method = "rk4"
)

out <- as.data.frame(out)
```

Incidence : 
```{r}
# Incidence : nbr nvlles infections par intervalle de tps 
# sigma x E (nbr indiv qui passent de E à I par jour)
# Incidence en nbr indiv/jours
out$incidence <- parameters["sigma_H"] * out$E_H

# Cas observés : nbr de cas détectés par jour 
taux_detec <- 1 #le faire varier : début infection (X%) vs fin infcetion (100%)
out$incidence_obs <- taux_detec * parameters["p"] * out$incidence
out$cumule <- cumsum(out$incidence_obs)

out <- cbind(out, tt_data)
```

```{r}
plot(out$time, out$incidence_obs,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence journalière")
lines(out$time+40, tt_data$cases)

plot(out$time, out$cumule,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence cumulée")
lines(out$time, tt_data$cumule)
```
Décalage des dates !!! On a pas le début de l'épidémie

```{r}
indic_week <- tapply(out$incidence_obs, floor(out$time/7), sum)

plot(data_sem$week, indic_week,
     type = "l", lwd = 2,
     xlab = "Temps (semaine depuis le début de l'étude)",
     ylab = "Incidence hebdomadaire")
lines(data_sem$week, data_sem$cases)
```

```{r}
outA <- ode(
  y = init,
  times = times,
  func = SEIAR_SEI,
  parms = parameters,
  method = "rk4"
)

outA <- as.data.frame(outA)
```

```{r}
outA$incidence <- parameters["sigma_H"] * outA$E_H
```

```{r}
plot(outA$time, outA$incidence*55000*0.2,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence journalière")

```


# Inférence des paramètres : ABC rejection
Critère à optimiser : Somme des carrés des écarts (incidence à la fin de l'épidémie + incidence cumulée)
La SSE pénalise fortement les écarts importants, ce qui la rend sensible aux valeurs aberrantes. Elle est adaptée lorsque les erreurs sont supposées suivre une distribution normale.   
Si distribution non normale : erreur absolue moyenne (MAE)    


Probleme : on simule à partir du 1er infecté / les data commencent au 1er cas détécté. Le modèle a du retard ! (entre : incubation, propagation, asympto...). Si on décale pas, incidence sur le pas de temps plate !
```{r}
T = 1000

df_param <- data.frame(
  # Stat résumées : 
  # dist_cumul = rep(NA, T), 
  #SCE = rep(NA, T),
  MAE = rep(NA, T),
  #MAE_inci = rep(NA, T),
  # max_pic = rep(NA,T),
  # temp_pic = rep(NA,T),
  # Priors testés : 
  beta = runif(T, min = 0, max = 3), 
  theta = runif(T, min = 0, max = 1.5), 
  p = runif(T, min = 0.1, max = 0.8) 
)

for (i in 1:T){
  
  # Echantillonnage des param --------------------------------------------------
  parameters <- c(
  N_H = 54500,
  beta = df_param[i,]$p,
  sigma_H = 1/5.7, #selon biblio
  gamma_I = 1/4.7, #selon biblio
  gamma_A = 1/4.7, #selon biblio
  p = df_param[i,]$p,
  theta = df_param[i,]$theta)
  
  # Simulation des données -----------------------------------------------------
  out <- ode(
  y = init,
  times = times_sim, #sur le temps du modele : + long 
  func = SEIAR,
  parms = parameters,
  method = "rk4")
  
  # Cacul incidence ----------------------------------------------------
  out <- as.data.frame(out)
  out$incidence <- parameters["sigma_H"] * out$E_H * parameters["p"] # durée incubation x nbr d'exposés x proba symptomatique 
  
  # Remettre les data au même niveau que le modèle : décqlage tempo ---------------------------------------
  # Prendre 1er temps où inicidence obs = 1 (1er cas)
  t_align <- which(out$incidence >= 1)[1] 
  # si t_align = NA : jamais inicidence de 1, on n'enregistre pas la simulation 
  if(!is.na(t_align)){
    out <- out[t_align:(t_align + nrow(tt_data) - 1), ] # prendre 147 jours après le 1er cas détecté par le modèle
    out <- cbind(out, tt_data) #jointure avec le tableau des données observées 
  
    out_week <- out %>%
      mutate(week = floor(as.numeric(date - min(date))/7)) %>% #création des semianes 
      group_by(week) %>%
      summarize(cases_obs = sum(cases, na.rm = TRUE), #somme par semaine obs 
                cases_sim = sum(incidence, na.rm = TRUE)) %>%
      ungroup() %>%
      arrange(week) %>%
      mutate(cases_obs_cum = cumsum(cases_obs), # cumul pour chaque semaine 
            cases_sim_cum = cumsum(cases_sim))
# distance <- MAE_week + 0.1 * penalty_final 
  
  # Calcul de la distance ------------------------------------------------------
    # dist <- out_week %>% 
    #   summarise(SCE = sum((cases_obs_cum - cases_sim_cum)^2), # SSE sur l'incidence cumulée
    #             MAE = mean(abs(cases_obs - cases_sim))) # MAE sur l'incidence
      dist <- out_week %>% 
       summarise(MAE = mean(abs(cases_obs_cum - cases_sim_cum))) # MAE sur l'incidence cumulée
  
  
  # Valeur derniere incidence cumulée
    #last_incidence <- abs(last(out_week$cases_obs_cum) - last(out_week$cases_sim_cum))
  
    #df_param[i,]$SCE <- dist$SCE
    #df_param[i,]$MAE_inci <- dist$MAE + 0.1*last_incidence
    df_param[i,]$MAE <- dist$MAE
  }
  
  
    # print(i)
}

# Distance SCE -----------------------------------------------------------------
# df_param = df_param[order(df_param$MAE, decreasing = FALSE),] # ranger les erreurs
df_param = df_param[order(df_param$SCE, decreasing = FALSE),] 

df_subset <- df_param[c(1:50),c("beta","theta","p")] # garder les x meilleurs
```


```{r}
ggpairs(df_subset)
```


Simulation de la meilleure distance : 
```{r}
i=1

parameter_closest <- c(
  N_H = 54500,
  beta = df_subset[i,]$beta,
  sigma_H = 1/5.7,
  gamma_I = 1/4.7,
  gamma_A = 1/4.7,
  p = df_subset[i,]$p,
  theta = df_subset[i,]$theta)

out_close <- ode(
  y = init,
  times = times_sim,
  func = SEIAR,
  parms = parameter_closest,
  method = "rk4")

out_close <- as.data.frame(out_close)
out_close$incidence <- parameter_closest["sigma_H"] * out_close$E_H * parameter_closest["p"]
```

Remettre au bon pas temporel et affichage :
```{r}
t_align <- which(out_close$incidence >= 1)[1]
out_close_tempo <- out_close[t_align:(t_align + nrow(tt_data) - 1), ] # prendre 147 jours après le 1er cas détecté par le modèle

# lier avec le dataframe des données
df_out <- cbind(out_close_tempo, tt_data) %>%
  group_by(week) %>% # somme par semaine
  summarize(cases_obs = sum(cases, na.rm = TRUE), 
            cases_sim = sum(incidence, na.rm = TRUE)) %>%
  mutate(cumule_obs = cumsum(cases_obs), 
         cumule_sim = cumsum(cases_sim))
  

plot(df_out$week, df_out$cumule_obs,  col = "blue")
lines(df_out$cumule_sim, col = "red")

plot(df_out$week, df_out$cases_obs,  col = "blue")
lines(df_out$cases_sim, col = "red")

plot(df_out$cases_sim)
plot(df_out$cumule_sim)
```

Bon ça marche pas top, peut être que l'exploration de l'espace des paramètres est pas top ? ou la distance choisie.ou les summary stat


## Cross validation de nos paramètres
```{r}
setDT(df_param)

cv_zika <- cv4abc(param = df_param[,.(beta,theta,p)], sumstat = df_param[,MAE], nval = 500, tols =c(0.1), method = "rejection")

plot(cv_zika)
summary(cv_zika)
```
Très mauvais pour beta et theta


## ABC rejection
```{r}
Tol = 0.1
setDT(df_param)

test_abc_n <- abc(target = c(0), param = df_param[,.(beta,theta,p)], 
                  # sumstat = df_param[,.(dist_cumul, MAE)], 
                  sumstat = df_param[,MAE], 
                  tol = Tol , method = "rejection")

summary(test_abc_n)
hist(test_abc_n)
plot(test_abc_n, param = df_param[,.(beta,theta,p)])
```
Donne quelque chose mais on peut pas faire confiance si nos paramètres sont pas identifiables