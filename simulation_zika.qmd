---
title: "Epidemie_Zika"
date: "`r Sys.Date()`"
format:
  html:
    toc: true
    toc-floating: true
    number-sections: true
    code-fold: true
    embed-resources: true
    toc-depth: 4
    theme: cosmo
    highlight-style: pygments
    fig.align: center
---

# Packages

```{r, message = FALSE, warning = FALSE}
library(outbreaks)
library(dplyr)
library(ggplot2)
library(deSolve)
library(abc)
library(ggplot2)
library(data.table)

# install.packages("devtools")
# Installer BRREWABC depuis GitHub
library(devtools)
# install_github("gaelbn/BRREWABC")
library(BRREWABC)
library(GGally)
```

# Data
```{r}
data <- zika_sanandres_2015
data$cumule <- cumsum(data$cases)
```

```{r}
plot(data, pch = 19)
plot(x= data$date, y=data$cumule)

ggplot(data, aes(x = date, y = cases))+
  geom_line() + 
  geom_point(alpha = 0.7) +
  theme_bw()
```

## Rajouter les pas de temps manquants (avec des NA)
Pour avoir la bonne taille de data.frame (par rapport à la simulation)
```{r}
tt_data <- seq(from = min(data$date), to = max(data$date), by = "day")
tt_data <- data.frame(date = tt_data) %>%
  left_join(., data, by = "date") %>%
  mutate(week = floor(as.numeric(date - min(date))/7))
```

## Données en cumulées par semaine depuis le début de suivi
```{r}
data_sem <- tt_data %>%
  group_by(week) %>%
  summarize(cases = sum(cases, na.rm = TRUE)) %>%
  mutate(cumule = cumsum(cases))
```

## Données météo 
```{r}
# plot(as.Date(era5$valid_time), era5$tp)
# plot(as.Date(era5$valid_time), era5$sst)
```

```{r}
# data %>%
#   left_join(., era5, by = c("date" = "valid_time"))
```

# SEIR + SEI discret
```{r}
seirs_ode <- function(t, state, pars) {
  with(as.list(c(state, pars)), {
    
    N_H <- S_H + E_H + I_H + R_H
    N_M <- S_M + E_M + I_M
    
    lambda_H <- a * b_MH * I_M / N_H  # force of infection
    lambda_M <- a * b_HM * I_H / N_H
    
    # Humains 
    dS_H <-  - lambda_H * S_H 
    dE_H <-  lambda_H * S_H - sigma_H * E_H
    dI_H <-  sigma_H * E_H - gamma_H * I_H
    dR_H <-  gamma_H * I_H
    
    # Moustiques
    dS_M <-  mu_M * N_M - lambda_M * S_M - mu_M * S_M
    dE_M <-  lambda_M * S_M - sigma_M * E_M - mu_M * E_M
    dI_M <-  sigma_M * E_M - mu_M * I_M

    list(c(dS_H, dE_H, dI_H, dR_H,
      dS_M, dE_M, dI_M))
  })
}
```

Paramètres : 
```{r}
parameters <- c(

  # Populations
  N_H = 55000,
  N_M = 30000, # ?

  # Transmission
  a     = 0.5,      # piqûres / moustique / jour
  b_MH  = 0.3,      # moustique -> humain
  b_HM  = 0.3,      # humain -> moustique

  # Humains
  sigma_H = 1/5,    # durée incubation humaine : 5j
  gamma_H = 1/5,    # durée infection : 4.7j

  # Moustiques
  sigma_M = 1/10,   # durée incubation : 10j ?
  mu_M    = 1/15    # durée vie : 10j ?
)
```

Insecticide dans les avions : transmission du zika à San Andrès vient de H
```{r}
init <- c(
  S_H = as.numeric(parameters["N_H"] - 1),
  E_H = 0,
  I_H = 1,
  R_H = 0,

  S_M = as.numeric(parameters["N_M"]),
  E_M = 0,
  I_M = 0
)

times <- seq(0, 146, by = 1) # mettre + long 

out <- ode(
  y = init,
  times = times,
  func = seirs_ode,
  parms = parameters,
  method = "rk4"
)

out <- as.data.frame(out)
```

Incidence : nombre de nouvelles infectionns par jour 
```{r}
out$incidence <- parameters["sigma_H"] * out$E_H

plot(out$time, out$incidence,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence journalière")
```

a, B_MH, b_HM, NM pas identifiables (juste leur combi)

# Asympto E divisé en I et A
```{r}
SEIAR_SEI <- function(t, state, parameters) {

  with(as.list(c(state, parameters)), {

    # Forces d'infection
    lambda_H <- a * b_MH * I_M / N_H
    lambda_M <- a * b_HM * (I_H + theta * A_H) / N_H

    # Humains
    dS_H <- -lambda_H * S_H
    dE_H <-  lambda_H * S_H - sigma_H * E_H
    dI_H <-  p * sigma_H * E_H - gamma_I * I_H
    dA_H <- (1 - p) * sigma_H * E_H - gamma_A * A_H
    dR_H <-  gamma_I * I_H + gamma_A * A_H

    # Moustiques
    dS_M <-  mu_M * N_M - lambda_M * S_M - mu_M * S_M
    dE_M <-  lambda_M * S_M - sigma_M * E_M - mu_M * E_M
    dI_M <-  sigma_M * E_M - mu_M * I_M

    list(c(
      dS_H, dE_H, dI_H, dA_H, dR_H,
      dS_M, dE_M, dI_M
    ))
  })
}

```

```{r}
parameters <- c(
  
  # Taille pop
  N_H = 55000,
  N_M = 30000, #?

  p     = 0.2,    # proportion symptomatique
  theta = 0.7,    # infectiosité asympto
  
  # Transmission
  a     = 0.5,      # piqûres / moustique / jour
  b_MH  = 0.3,      # moustique -> humain
  b_HM  = 0.3,      # humain -> moustique

  # Humains
  sigma_H = 1/5,    # durée incubation humaine : 5j
  gamma_I = 1/7,
  gamma_A = 1/7,    # durée infection : 4.7j

  # Moustiques
  sigma_M = 1/10,   # durée incubation : 10j ?
  mu_M    = 1/15    # durée vie : 10j ?
)

```

```{r}
init <- c(
  S_H = as.numeric(parameters["N_H"]) - 1,
  E_H = 0,
  I_H = 1,
  A_H = 0,
  R_H = 0,

  S_M = as.numeric(parameters["N_M"]),
  E_M = 0,
  I_M = 0
)

times <- seq(0, 146, by = 1) # mettre + long 
```

```{r}
out <- ode(
  y = init,
  times = times,
  func = SEIAR_SEI,
  parms = parameters,
  method = "rk4"
)

out <- as.data.frame(out)
```

```{r}
out$incidence <- parameters["sigma_H"] * out$E_H
```

```{r}
plot(out$time, out$incidence * 55000*0.2,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence journalière")
lines(date$cases)
```

# Sans les moustiques avec Asympto E divisé en I et A
```{r}
SEIAR <- function(t, state, parameters) {

  with(as.list(c(state, parameters)), {

    # Forces d'infection integrant moustiques
    lambda_H <- beta * (I_H + theta * A_H) / N_H

    # Humains
    dS_H <- -lambda_H * S_H
    dE_H <-  lambda_H * S_H - sigma_H * E_H
    dI_H <-  p * sigma_H * E_H - gamma_I * I_H
    dA_H <- (1 - p) * sigma_H * E_H - gamma_A * A_H
    dR_H <-  gamma_I * I_H + gamma_A * A_H

    list(c(
      dS_H, dE_H, dI_H, dA_H, dR_H
    ))
  })
}

```

```{r}
parameters <- c(
  
  # Taille pop
  N_H = 55000,

  # Transmission 
  beta = 0.5, #A MODIFIER !!!!

  # Humains
  sigma_H = 1/5,
  gamma_I = 1/7,
  gamma_A = 1/7,

  p     = 0.2,   # proportion symptomatique
  theta = 0.7    # infectiosité asympto
)
```


```{r}
init <- c(
  S_H = as.numeric(parameters["N_H"]) - 1,
  E_H = 0,
  I_H = 1,
  A_H = 0,
  R_H = 0
)

times_obs <- seq(0, 146, by = 1) # mettre + long 
times_sim <- seq(0, 500, by = 1) # mettre + long 
```

```{r}
out <- ode(
  y = init,
  times = times,
  func = SEIAR,
  parms = parameters,
  method = "rk4"
)

out <- as.data.frame(out)
```

Incidence : 
```{r}
# Incidence : nbr nvlles infections par intervalle de tps 
# sigma x E (nbr indiv qui passent de E à I par jour)
# Incidence en nbr indiv/jours
out$incidence <- parameters["sigma_H"] * out$E_H

# Cas observés : nbr de cas détectés par jour 
taux_detec <- 1 #le faire varier : début infection (X%) vs fin infcetion (100%)
out$incidence_obs <- taux_detec * parameters["p"] * out$incidence
out$cumule <- cumsum(out$incidence_obs)

out <- cbind(out, tt_data)
```

```{r}
plot(out$time, out$incidence_obs,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence journalière")
lines(out$time+40, tt_data$cases)

plot(out$time, out$cumule,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence cumulée")
lines(out$time, tt_data$cumule)
```
Décalage des dates !!! On a pas le début de l'épidémie

```{r}
indic_week <- tapply(out$incidence_obs, floor(out$time/7), sum)

plot(data_sem$week, indic_week,
     type = "l", lwd = 2,
     xlab = "Temps (semaine depuis le début de l'étude)",
     ylab = "Incidence hebdomadaire")
lines(data_sem$week, data_sem$cases)
```

```{r}
outA <- ode(
  y = init,
  times = times,
  func = SEIAR_SEI,
  parms = parameters,
  method = "rk4"
)

outA <- as.data.frame(outA)
```

```{r}
outA$incidence <- parameters["sigma_H"] * outA$E_H
```

```{r}
plot(outA$time, outA$incidence*55000*0.2,
     type = "l", lwd = 2,
     xlab = "Temps (jours)",
     ylab = "Incidence journalière")

```


# Inférence des paramètres : ABC rejection
Critère à optimiser : Somme des carrés des écarts (incidence à la fin de l'épidémie + incidence cumulée)
La SSE pénalise fortement les écarts importants, ce qui la rend sensible aux valeurs aberrantes. Elle est adaptée lorsque les erreurs sont supposées suivre une distribution normale.   
Si distribution non normale : erreur absolue moyenne (MAE)    

```{r}
stat_resum_data <- data.frame(dist_cumul = sum(data$cases), #inicidence cumulée
  dist_incidence = data$cases[101], #incidence au dernier jour
  max_pic = max(data$cases),
  temp_pic = which.max(data$cases))
```

Probleme : on simule à partir du 1er infecté / les data commencent au 1er cas détécté. Le modèle a du retard !!! (entre : incubation, propagation, asympto...). Si on décale pas, incidence sur le pas de temps plate !!
```{r}
T = 10000

df_param <- data.frame(
  # Stat résumées : 
  # dist_cumul = rep(NA, T), 
  SCE = rep(NA, T),
  MAE = rep(NA, T),
  MAE_inci = rep(NA, T),
  cumul = rep(NA,T), #c'est quoi ça déjà ?
  # max_pic = rep(NA,T),
  # temp_pic = rep(NA,T),
  # Priors testés : 
  beta = runif(T, min = 0, max = 0.8),
  theta = runif(T, min = 0, max = 1.5), 
  p = runif(T, min = 0.1, max = 0.8) #monter de 0.1 à 0.8 (c'est bcp, mais on teste)
)

for (i in 1:T){
  
  # Echantillonnage des param --------------------------------------------------
  parameters <- c(
  N_H = 55000,
  beta = df_param[i,]$beta,
  sigma_H = 1/5.7, #
  gamma_I = 1/4.7,
  gamma_A = 1/4.7,
  p = df_param[i,]$p,
  theta = df_param[i,]$theta)
  
  # Simulation des données -----------------------------------------------------
  out <- ode(
  y = init,
  times = times_sim, #sur le temps du modele : + long 
  func = SEIAR,
  parms = parameters,
  method = "rk4")
  
  # Cacul incidence ----------------------------------------------------
  out <- as.data.frame(out)
  out$incidence <- parameters["sigma_H"] * out$E_H * parameters["p"] # durée incubation x nbr d'exposés x proba symptomatique 
  
  # Remettre les data au même niveau que le modèle : décélage tempo ---------------------------------------
  # Prendre 1er temps où inicidence obs = 1 (1er cas)
  t_align <- which(out$incidence >= 1)[1] 
  # si t_align = NA : jamais inicidence de 1, on vire le modèle 
  if(!is.na(t_align)){
    out <- out[t_align:(t_align + nrow(tt_data) - 1), ] # prendre 147 jours après le 1er cas détecté par le modèle
    out <- cbind(out, tt_data) #lien avec le data des données 
  
    out_week <- out %>%
      mutate(week = floor(as.numeric(date - min(date))/7)) %>% #création des semianes 
      group_by(week) %>%
      summarize(cases_obs = sum(cases, na.rm = TRUE), #somme par semaine obs 
                cases_sim = sum(incidence, na.rm = TRUE)) %>%
      ungroup() %>%
      arrange(week) %>%
      mutate(cases_obs_cum = cumsum(cases_obs), # cumul pour chaque semaine 
            cases_sim_cum = cumsum(cases_sim))
# distance <- MAE_week + 0.1 * penalty_final 
  
  # Calcul de la distance ------------------------------------------------------
    dist <- out_week %>% 
      summarise(SCE = sum((cases_obs_cum - cases_sim_cum)^2), # SSE
                MAE = mean(abs(cases_obs - cases_sim))) # MAE
  
  # Valeur derniere incidence cumulée
    last_incidence <-  abs(last(out_week$cases_obs_cum) - last(out_week$cases_sim_cum))
  
    df_param[i,]$SCE <- dist$SCE
    df_param[i,]$MAE_inci <- dist$MAE + 0.1*last_incidence
    df_param[i,]$MAE <- dist$MAE
  }
  
  
    # print(i)
}

# Distance SCE -----------------------------------------------------------------
df_param = df_param[order(df_param$MAE, decreasing = FALSE),] # ranger les erreurs

df_subset <- df_param[c(1:500),c("beta","theta","p")] # garder les 500 meilleurs
```


```{r}
ggpairs(df_subset)

setDT(df_param)
df_cumul_tronc <- df_param[cumul<5000]
ggplot(data = df_cumul_tronc)+
  geom_point(x=df_cumul_tronc[,p], y= df_cumul_tronc[,beta], color = df_cumul_tronc[,cumul])
```

Si on prend le cumul à la fin, c'est pas grave si on a pas le début de l'épidémie. On voit dans nos données qu'il y a presque aucun nouveau cas à la fin. 

Calcul de la distribution a prosteriori : 
```{r}
i=1

parameter_closest <- c(
  N_H = 55000,
  beta = df_subset[i,]$beta,
  sigma_H = 1/5.7,
  gamma_I = 1/4.7,
  gamma_A = 1/4.7,
  p = df_subset[i,]$p,
  theta = df_subset[i,]$theta)

out_close <- ode(
  y = init,
  times = times_sim,
  func = SEIAR,
  parms = parameter_closest,
  method = "rk4")

out_close <- as.data.frame(out_close)
out_close$incidence <- parameter_closest["sigma_H"] * out_close$E_H * parameter_closest["p"]
```

Remettre au bon pas temporel :
```{r}
t_align <- which(out_close$incidence >= 1)[1]
out_close_tempo <- out_close[t_align:(t_align + nrow(tt_data) - 1), ] # prendre 147 jours après le 1er cas détecté par le modèle

# lier avec le dataframe des données
df_out <- cbind(out_close_tempo, tt_data) %>%
  group_by(week) %>% # somme par semaine
  summarize(cases_obs = sum(cases, na.rm = TRUE), 
            cases_sim = sum(incidence, na.rm = TRUE)) %>%
  mutate(cumule_obs = cumsum(cases_obs), 
         cumule_sim = cumsum(cases_sim))
  

plot(df_out$week, df_out$cumule_obs,  col = "blue")
lines(df_out$cumule_sim, col = "red")

plot(df_out$week, df_out$cases_obs,  col = "blue")
lines(df_out$cases_sim, col = "red")

plot(df_out$cases_sim)
plot(df_out$cumule_sim)
```

Pas temporel avec début à incidence du modele = 1 + délai de 20jours :   
C'est bcp mais ça coincide
```{r}
t_align <- which(out_close$incidence >= 1)[1]
out_close_tempo <- (out_close[t_align:(t_align + nrow(tt_data) - 1), ]+10) # prendre 147 jours après le 1er cas détecté par le modèle

# lier avec le dataframe des données
df_out <- cbind(out_close_tempo, tt_data) %>%
  group_by(week) %>% # somme par semaine
  summarize(cases_obs = sum(cases, na.rm = TRUE), 
            cases_sim = sum(incidence, na.rm = TRUE)) %>%
  mutate(cumule_obs = cumsum(cases_obs), 
         cumule_sim = cumsum(cases_sim))
  

plot(df_out$week, df_out$cumule_obs,  col = "blue")
lines(df_out$cumule_sim, col = "red")

plot(df_out$week, df_out$cases_obs,  col = "blue")
lines(df_out$cases_sim, col = "red")

plot(df_out$cases_sim)
plot(df_out$cumule_sim)
```


Bon ça marche pas top, peut être que l'exploration de l'espace des paramètres est pas top ? ou la distance choisie.ou les summary stat

```{r}
Tol = 0.1

test_abc_n <- abc(target = c(928,1), param = df_param[,.(beta,theta,p)], 
                  sumstat = df_param[,.(dist_cumul, MAE)], 
                  tol = Tol , method = "neuralnet")

summary(test_abc_n)
hist(test_abc_n)
plot(test_abc_n, param = df_param[,.(beta,theta,p)])
```

## ABC SMC 
Je tente autre méthode (pas encore prêt à faire tourner)

```{r}
# Distributions a priori uniformes pour beta theta et p
priors <- list(
  beta = list(dist = "unif", min = 0, max = 1),
  theta = list(dist = "unif", min = 0, max = 1.5),
  p = list(dist = "unif", min = 0, max = 1)
)
```

```{r}
# Fonction pour calculer les statistiques résumés
summary_stats <- function(data) {
  return(data$I)
}

# Calcul des statistiques résumés observés
summary_obs <- summary_stats(data.frame(I = I_obs))

# Fonction de distance (somme des carrés des différences)
distance_function <- function(summary_sim, summary_obs) {
  return(sum((summary_sim - summary_obs)^2))
}
```

